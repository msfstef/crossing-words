---
phase: 10-gameplay-flow-improvements
plan: 03
type: execute
---

<objective>
Auto-generate timeline when opening puzzles and auto-rejoin on return for seamless collaboration experience.

Purpose: Currently timeline is only created when user clicks "Share". This means solo solving doesn't persist a timeline, and returning to a puzzle doesn't automatically rejoin P2P. Auto-timeline enables instant sharing readiness and seamless session resumption.

Output: Every puzzle open generates/uses a timeline, enabling instant collaboration and automatic session recovery.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/App.tsx
@src/collaboration/timelineStorage.ts
@src/collaboration/sessionUrl.ts

**Tech stack available:** React, localStorage, IndexedDB
**Established patterns:** localStorage for timeline mappings, URL hash for share state

**Current implementation:**
- `timelineId` state starts undefined
- Timeline only generated in `handleShare` callback
- `getCurrentTimeline(puzzleId)` checks localStorage for stored timeline
- `saveTimelineMapping(puzzleId, timelineId)` stores to localStorage
- URL hash updated only when sharing
- When joining shared link, timeline stored after merge/fresh choice

**Key insight:** The timeline enables P2P room creation. With auto-timeline, every puzzle session is immediately P2P-ready.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate timeline when opening puzzle from library</name>
  <files>src/App.tsx</files>
  <action>
Modify `handleOpenPuzzle` to generate and set timeline:

1. In `handleOpenPuzzle` callback, after setting puzzle and puzzleId:
   ```typescript
   const handleOpenPuzzle = useCallback((loadedPuzzle: Puzzle, loadedPuzzleId: string) => {
     setPuzzle(loadedPuzzle);
     setActivePuzzleId(loadedPuzzleId);
     setActiveView('solve');
     setError(null);

     // Generate timeline for this puzzle session
     const newTimelineId = generateTimelineId();
     setTimelineId(newTimelineId);

     // Store mapping and update URL
     saveTimelineMapping(loadedPuzzleId, newTimelineId);
     updateUrlHash(loadedPuzzleId, newTimelineId);

     // Persist puzzle
     saveCurrentPuzzle(loadedPuzzle).catch(console.error);
   }, []);
   ```

2. This ensures every puzzle open creates a P2P room immediately

3. The Share button flow can be simplified - it no longer needs to generate timeline, just build and show the URL (timeline already exists)

4. Update `handleShare` to remove timeline generation logic since it's now always present:
   ```typescript
   const handleShare = useCallback(() => {
     if (!puzzle || !puzzleId || !timelineId) return;
     const url = buildShareUrl(puzzleId, timelineId);
     setShareUrl(url);
     setShowShareDialog(true);
   }, [puzzle, puzzleId, timelineId]);
   ```

Note: This is a behavior change - previously solo solving had no P2P room. Now every session is P2P-enabled. This is the intended design per roadmap.
  </action>
  <verify>
`npm run build` succeeds. Open a puzzle from library - URL should immediately contain `#puzzle=X&timeline=Y`. Timeline should be visible in localStorage (`timeline:puzzleId`).
  </verify>
  <done>Opening puzzle from library immediately generates timeline, updates URL, stores mapping.</done>
</task>

<task type="auto">
  <name>Task 2: Auto-rejoin timeline when returning to puzzle</name>
  <files>src/App.tsx</files>
  <action>
Check for existing timeline when opening puzzle:

1. Modify `handleOpenPuzzle` to check for existing timeline first:
   ```typescript
   const handleOpenPuzzle = useCallback((loadedPuzzle: Puzzle, loadedPuzzleId: string) => {
     setPuzzle(loadedPuzzle);
     setActivePuzzleId(loadedPuzzleId);
     setActiveView('solve');
     setError(null);

     // Check for existing timeline (returning to puzzle)
     const existingTimeline = getCurrentTimeline(loadedPuzzleId);

     if (existingTimeline) {
       // Rejoin existing timeline
       setTimelineId(existingTimeline);
       updateUrlHash(loadedPuzzleId, existingTimeline);
     } else {
       // New puzzle session - generate timeline
       const newTimelineId = generateTimelineId();
       setTimelineId(newTimelineId);
       saveTimelineMapping(loadedPuzzleId, newTimelineId);
       updateUrlHash(loadedPuzzleId, newTimelineId);
     }

     // Persist puzzle
     saveCurrentPuzzle(loadedPuzzle).catch(console.error);
   }, []);
   ```

2. This enables "session resumption" - if you were collaborating, closing and reopening the puzzle puts you back in the same P2P room

3. Collaborators who are still connected will see you rejoin automatically

This maintains the user's collaborative context across app restarts or navigation.
  </action>
  <verify>
`npm run build` succeeds. Open puzzle, note timeline ID, go back to library, reopen same puzzle - should use same timeline ID (check URL and localStorage).
  </verify>
  <done>Returning to a puzzle auto-rejoins the stored timeline/P2P room.</done>
</task>

<task type="auto">
  <name>Task 3: Store received timeline when joining via shared link</name>
  <files>src/App.tsx</files>
  <action>
Ensure timeline is saved when joining a shared session:

1. In the `processJoin` async function (inside the effect that handles `pendingUrlTimeline`), the timeline is already saved via `saveTimelineMapping` when there's no conflict

2. Verify the "no conflict" path saves the mapping:
   ```typescript
   // No conflict - just join the shared timeline
   setTimelineId(pendingUrlTimeline);
   await saveTimelineMapping(puzzleId, pendingUrlTimeline);  // This should exist
   ```

3. Verify `handleJoinMerge` saves the mapping (it does: `await saveTimelineMapping(puzzleId, pendingTimelineId)`)

4. Verify `handleJoinStartFresh` saves the mapping (it does: `await saveTimelineMapping(puzzleId, pendingTimelineId)`)

5. Add save to `handlePuzzleReceived` callback for the case where puzzle is received from sharer:
   ```typescript
   const handlePuzzleReceived = useCallback((receivedPuzzle: Puzzle) => {
     // ... existing code ...

     // Store the timeline mapping for future rejoins
     if (pendingUrlTimeline) {
       saveTimelineMapping(newPuzzleId, pendingUrlTimeline);
     }
   }, [pendingUrlTimeline]);
   ```
   Note: Need to add `pendingUrlTimeline` to dependency array or use a ref.

6. This ensures that after joining via link, future opens of this puzzle will rejoin the same timeline

The key insight: joining someone's shared link should make that timeline YOUR timeline for that puzzle going forward.
  </action>
  <verify>
`npm run build` succeeds. Join a shared link (from another tab), complete the join. Go back to library, reopen that puzzle - should rejoin the same timeline (the one from the shared link).
  </verify>
  <done>Joining via shared link stores timeline mapping, enabling future auto-rejoin.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Opening puzzle from library creates timeline immediately
- [ ] URL hash updates with puzzle+timeline on open
- [ ] Returning to puzzle uses stored timeline
- [ ] Joining shared link stores that timeline
- [ ] Future opens after join use the shared timeline
- [ ] Share button works without needing to generate timeline
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Every puzzle session is P2P-ready from the start
- Session continuity works across app restarts
- Shared link recipients become part of that timeline permanently
</success_criteria>

<output>
After completion, create `.planning/phases/10-gameplay-flow-improvements/10-03-SUMMARY.md`:

Include:
- New timeline auto-generation behavior
- Session resumption flow
- Shared link timeline persistence
- Any edge cases discovered
</output>
