# Phase 6.1: Cloudflare Worker Signaling - Research

**Researched:** 2026-01-12
**Domain:** Cloudflare Durable Objects WebSocket signaling for y-webrtc
**Confidence:** HIGH

<research_summary>
## Summary

Researched the Cloudflare ecosystem for implementing a production-ready signaling server for y-webrtc. The standard approach uses **Cloudflare Durable Objects with WebSocket Hibernation API** to replace the local `y-webrtc/bin/server.js` currently used in development.

Key finding: The y-webrtc signaling protocol is a simple pub/sub system with four message types (`subscribe`, `unsubscribe`, `publish`, `ping/pong`). This maps directly to Durable Objects where each "room" (puzzle+timeline) gets its own Durable Object instance that broadcasts messages between connected WebSocket clients.

The existing proxy worker (`crossing-words-proxy`) can be extended to add a `/signaling/:room` WebSocket endpoint, reusing the same Cloudflare account and deployment pipeline. This keeps infrastructure simple while adding production-ready P2P connectivity.

**Primary recommendation:** Add Durable Objects with WebSocket Hibernation to the existing proxy worker. Each room gets a DO instance via `idFromName(roomId)`. Implement the 4 y-webrtc message types. Use Hibernation API to minimize costs (~$0 for typical usage within free tier).
</research_summary>

<standard_stack>
## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Cloudflare Workers | N/A | HTTP routing, WebSocket upgrade | Already in use for proxy |
| Durable Objects | N/A | Stateful WebSocket room management | Official CF solution for real-time coordination |
| WebSocket Hibernation API | N/A | Cost-efficient WebSocket handling | Keeps connections alive without billing during idle |

### Supporting
| Tool | Purpose | When to Use |
|------|---------|-------------|
| wrangler | Deployment CLI | Development and production deploys |
| @cloudflare/workers-types | TypeScript definitions | Already installed in proxy |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Durable Objects | P2PCF (R2-based) | HTTP polling has higher latency, but avoids WebSocket complexity |
| Single DO for signaling | y-durableobjects | Full Yjs sync on DO, but we only need signaling - y-webrtc handles sync |
| Extending proxy | Separate Worker | More isolation but additional deployment complexity |

### Deployment:
Extends existing proxy:
```toml
# Add to existing wrangler.toml
[[durable_objects.bindings]]
name = "SIGNALING_ROOM"
class_name = "SignalingRoom"

[[migrations]]
tag = "v1"
new_classes = ["SignalingRoom"]
```

No additional npm packages needed.
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Project Structure (Extending Existing Proxy)
```
proxy/
├── src/
│   ├── index.ts           # Existing proxy + new signaling route
│   └── SignalingRoom.ts   # NEW: Durable Object class
├── wrangler.toml          # Add DO binding + migration
└── package.json           # No new deps needed
```

### Pattern 1: y-webrtc Signaling Protocol
**What:** Implement the 4 message types that y-webrtc expects
**When to use:** Any custom y-webrtc signaling server
**Protocol (from y-webrtc/bin/server.js):**
```typescript
// Message types:
// 1. subscribe: Client joins topic(s)
{ type: 'subscribe', topics: ['room-id-1', 'room-id-2'] }

// 2. unsubscribe: Client leaves topic(s)
{ type: 'unsubscribe', topics: ['room-id-1'] }

// 3. publish: Client sends message to room
{ type: 'publish', topic: 'room-id-1', ...payload }

// 4. ping/pong: Keep-alive (optional, CF handles)
{ type: 'ping' } -> { type: 'pong' }
```

### Pattern 2: Durable Object with Hibernation for Signaling
**What:** Use DO with hibernation API for WebSocket signaling
**When to use:** Production signaling with cost efficiency
**Example:**
```typescript
// SignalingRoom.ts
import { DurableObject } from 'cloudflare:workers';

interface Env {
  SIGNALING_ROOM: DurableObjectNamespace;
}

export class SignalingRoom extends DurableObject {
  // Map of topic -> Set of WebSocket connections subscribed
  private topics: Map<string, Set<WebSocket>> = new Map();

  async fetch(request: Request): Promise<Response> {
    // Handle WebSocket upgrade
    const upgradeHeader = request.headers.get('Upgrade');
    if (upgradeHeader !== 'websocket') {
      return new Response('Expected WebSocket', { status: 426 });
    }

    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);

    // Use hibernation API - connection survives DO eviction
    this.ctx.acceptWebSocket(server);

    return new Response(null, { status: 101, webSocket: client });
  }

  // Called when message received (even after hibernation)
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    if (typeof message !== 'string') return;

    try {
      const msg = JSON.parse(message);

      switch (msg.type) {
        case 'subscribe':
          this.handleSubscribe(ws, msg.topics || []);
          break;
        case 'unsubscribe':
          this.handleUnsubscribe(ws, msg.topics || []);
          break;
        case 'publish':
          this.handlePublish(ws, msg);
          break;
        case 'ping':
          ws.send(JSON.stringify({ type: 'pong' }));
          break;
      }
    } catch (e) {
      console.error('Failed to parse message:', e);
    }
  }

  private handleSubscribe(ws: WebSocket, topics: string[]) {
    for (const topic of topics) {
      if (!this.topics.has(topic)) {
        this.topics.set(topic, new Set());
      }
      this.topics.get(topic)!.add(ws);
    }
  }

  private handleUnsubscribe(ws: WebSocket, topics: string[]) {
    for (const topic of topics) {
      this.topics.get(topic)?.delete(ws);
    }
  }

  private handlePublish(ws: WebSocket, msg: any) {
    const topic = msg.topic;
    if (!topic) return;

    const subscribers = this.topics.get(topic);
    if (!subscribers) return;

    // Add client count for y-webrtc protocol
    const response = JSON.stringify({ ...msg, clients: subscribers.size });

    // Broadcast to all subscribers (including sender per y-webrtc protocol)
    for (const subscriber of subscribers) {
      try {
        subscriber.send(response);
      } catch (e) {
        // Connection closed, will be cleaned up in webSocketClose
      }
    }
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string) {
    // Remove from all topics
    for (const [topic, subscribers] of this.topics) {
      subscribers.delete(ws);
      if (subscribers.size === 0) {
        this.topics.delete(topic);
      }
    }
  }
}
```

### Pattern 3: Worker Routing to Durable Object
**What:** Route WebSocket upgrade requests to the appropriate DO instance
**When to use:** Entry point for signaling in the main worker
**Example:**
```typescript
// In index.ts (extend existing proxy)
export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);

    // ... existing puzzle proxy routes ...

    // NEW: WebSocket signaling route
    if (url.pathname.startsWith('/signaling/')) {
      const roomId = url.pathname.split('/signaling/')[1];
      if (!roomId) {
        return new Response('Missing room ID', { status: 400 });
      }

      // Each room gets its own DO instance
      const id = env.SIGNALING_ROOM.idFromName(roomId);
      const stub = env.SIGNALING_ROOM.get(id);
      return stub.fetch(request);
    }

    // ... rest of existing routes ...
  }
};

// Export the Durable Object class
export { SignalingRoom } from './SignalingRoom';
```

### Pattern 4: State Recovery After Hibernation
**What:** Restore topic subscriptions when DO wakes from hibernation
**When to use:** When using hibernation API with topics
**Example:**
```typescript
// In SignalingRoom constructor
constructor(ctx: DurableObjectState, env: Env) {
  super(ctx, env);

  // Restore hibernated connections and their topics
  for (const ws of this.ctx.getWebSockets()) {
    // Recover attached data (topics this WS subscribed to)
    const attachment = ws.deserializeAttachment() as { topics: string[] } | null;
    if (attachment?.topics) {
      for (const topic of attachment.topics) {
        if (!this.topics.has(topic)) {
          this.topics.set(topic, new Set());
        }
        this.topics.get(topic)!.add(ws);
      }
    }
  }
}

// When subscribing, save topics for recovery
private handleSubscribe(ws: WebSocket, topics: string[]) {
  // ... existing logic ...

  // Persist for hibernation recovery
  const existing = ws.deserializeAttachment() as { topics: string[] } | null;
  const allTopics = [...new Set([...(existing?.topics || []), ...topics])];
  ws.serializeAttachment({ topics: allTopics });
}
```

### Anti-Patterns to Avoid
- **One DO for all rooms:** Creates single point of contention; use `idFromName(roomId)` for room-per-DO
- **Standard WebSocket API (non-hibernation):** Billed for connection duration even when idle
- **Storing message history in DO:** Signaling is ephemeral; y-webrtc handles CRDT sync
- **Complex auth in DO:** Validate in Worker before routing to DO
- **Manual ping/pong handling:** CF WebSocket hibernation handles keep-alive automatically
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Signaling protocol | Custom protocol | y-webrtc's 4 message types | Compatibility with y-webrtc client |
| WebSocket keep-alive | Manual ping/pong timers | CF hibernation auto-response | Free, automatic, no code needed |
| Room isolation | Single DO with routing | `idFromName(roomId)` per room | Built-in isolation, better scaling |
| Connection cleanup | Manual timeouts | `webSocketClose` handler | CF calls it automatically |
| State persistence | Manual storage | `serializeAttachment` | Small state survives hibernation |
| WebSocket upgrade | Manual protocol handling | `WebSocketPair` + `acceptWebSocket` | Standard CF pattern |

**Key insight:** Cloudflare Durable Objects with hibernation handles 90% of signaling server complexity automatically. The only custom code needed is the y-webrtc message type routing (subscribe/unsubscribe/publish/ping).
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Using Standard WebSocket API Instead of Hibernation
**What goes wrong:** Billed for full connection duration even during idle periods
**Why it happens:** Using `ws.accept()` instead of `ctx.acceptWebSocket(ws)`
**How to avoid:** Always use hibernation API: `this.ctx.acceptWebSocket(server)`
**Warning signs:** High duration charges for signaling-only traffic

### Pitfall 2: Not Restoring State After Hibernation
**What goes wrong:** Topic subscriptions lost when DO wakes from hibernation
**Why it happens:** In-memory state (Map/Set) is cleared when DO hibernates
**How to avoid:** Use `serializeAttachment`/`deserializeAttachment` for subscription state
**Warning signs:** Clients stop receiving broadcasts after quiet period

### Pitfall 3: Single Durable Object for All Rooms
**What goes wrong:** All rooms share one DO, creating bottleneck and cross-room conflicts
**Why it happens:** Using static DO ID instead of room-based naming
**How to avoid:** Use `idFromName(roomId)` to get room-specific DO instance
**Warning signs:** Performance degrades with multiple concurrent rooms

### Pitfall 4: Forgetting to Export DO Class
**What goes wrong:** "Durable Object class not found" error on deploy
**Why it happens:** DO class not exported from Worker entry point
**How to avoid:** Export the class: `export { SignalingRoom } from './SignalingRoom';`
**Warning signs:** Deploy fails with class not found error

### Pitfall 5: Missing Migration in wrangler.toml
**What goes wrong:** "Must provide migrations" error on first deploy
**Why it happens:** New DO classes require migration declaration
**How to avoid:** Add `[[migrations]]` section with `new_classes` array
**Warning signs:** Deploy fails asking for migrations

### Pitfall 6: Over-Engineering Authentication
**What goes wrong:** Complex auth logic in DO slows down message handling
**Why it happens:** Trying to validate every message in DO
**How to avoid:** Validate in Worker before routing to DO; signaling is for discovery only
**Warning signs:** Increased latency for simple publish/subscribe operations
</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official Cloudflare documentation and y-webrtc source:

### Complete wrangler.toml (Extended from Existing Proxy)
```toml
# existing config
name = "crossing-words-proxy"
main = "src/index.ts"
compatibility_date = "2024-01-01"
account_id = "fed2683481f4e710185cbeaac94262e2"

[vars]
ALLOWED_ORIGINS = "*"

# NEW: Durable Objects for signaling
[[durable_objects.bindings]]
name = "SIGNALING_ROOM"
class_name = "SignalingRoom"

[[migrations]]
tag = "v1"
new_classes = ["SignalingRoom"]
```

### Minimal SignalingRoom Implementation
```typescript
// Source: CF Durable Objects docs + y-webrtc bin/server.js protocol
import { DurableObject } from 'cloudflare:workers';

export class SignalingRoom extends DurableObject {
  constructor(ctx: DurableObjectState, env: any) {
    super(ctx, env);
  }

  async fetch(request: Request): Promise<Response> {
    if (request.headers.get('Upgrade') !== 'websocket') {
      return new Response('Expected WebSocket', { status: 426 });
    }

    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);
    this.ctx.acceptWebSocket(server);

    return new Response(null, { status: 101, webSocket: client });
  }

  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    if (typeof message !== 'string') return;

    const msg = JSON.parse(message);

    if (msg.type === 'ping') {
      ws.send(JSON.stringify({ type: 'pong' }));
      return;
    }

    if (msg.type === 'publish' && msg.topic) {
      // Broadcast to all connections in this room
      const allWs = this.ctx.getWebSockets();
      const response = JSON.stringify({ ...msg, clients: allWs.length });

      for (const conn of allWs) {
        try { conn.send(response); } catch {}
      }
    }
  }

  async webSocketClose(ws: WebSocket) {
    // Cleanup handled automatically by CF
  }
}
```

### Client Configuration Update
```typescript
// In webrtcProvider.ts - update getSignalingServers()
function getSignalingServers(): string[] {
  if (import.meta.env.DEV) {
    return ['ws://localhost:4444'];
  }

  // Production: use deployed Cloudflare Worker
  return ['wss://crossing-words-proxy.<subdomain>.workers.dev/signaling/global'];
}
```

### Testing WebSocket Locally with Wrangler
```bash
# Terminal 1: Start dev server
cd proxy && npx wrangler dev

# Terminal 2: Test WebSocket with wscat
npx wscat -c ws://localhost:8787/signaling/test-room

# Send test messages
{"type":"subscribe","topics":["test-room"]}
{"type":"ping"}
{"type":"publish","topic":"test-room","data":"hello"}
```
</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Heroku signaling servers | Cloudflare Durable Objects | 2023+ | Free tier, hibernation reduces costs to ~$0 |
| Standard WebSocket API | WebSocket Hibernation API | 2024+ | Only billed for active processing, not connection time |
| Separate signaling service | Extend existing Worker | Stable | Simpler infrastructure, single deployment |
| Key-value storage backend | SQLite storage backend | 2024+ | Better for complex state (not needed for signaling) |

**New tools/patterns to consider:**
- **WebSocket Auto-Response:** `setWebSocketAutoResponse()` can handle ping/pong without waking DO
- **Durable Object RPC:** Alternative to fetch-based DO communication, not needed for WebSocket
- **Point-in-Time Recovery:** For SQLite-backed DOs, not relevant for ephemeral signaling

**Deprecated/outdated:**
- **y-webrtc-signaling-eu/us.herokuapp.com:** Heroku ended free tier, these are unreliable
- **signaling.yjs.dev public server:** Shared/rate-limited, not for production
- **Manual keep-alive timers:** CF hibernation handles this automatically
</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Topic state across hibernation**
   - What we know: `serializeAttachment` persists up to 2KB per WebSocket
   - What's unclear: Whether topic recovery is necessary given y-webrtc re-subscribes on reconnect
   - Recommendation: Start simple without attachment; add if re-subscribe doesn't work reliably

2. **CORS for WebSocket upgrade**
   - What we know: Browser WebSocket API doesn't send CORS headers the same way
   - What's unclear: Whether existing CORS headers in proxy affect WebSocket connections
   - Recommendation: Test WebSocket connections from production domain; add headers if needed

3. **Optimal room ID strategy**
   - What we know: y-webrtc uses `roomId` which we set to `puzzleId:timelineId`
   - What's unclear: Whether `/signaling/:room` should be the puzzleId:timelineId or just a single global room
   - Recommendation: Start with single `/signaling/global` route; room isolation happens via topics in y-webrtc protocol
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [Cloudflare Durable Objects WebSocket docs](https://developers.cloudflare.com/durable-objects/best-practices/websockets/) - Hibernation API patterns
- [WebSocket Hibernation Server Example](https://developers.cloudflare.com/durable-objects/examples/websocket-hibernation-server/) - Complete DO implementation
- [Durable Objects Pricing](https://developers.cloudflare.com/durable-objects/platform/pricing/) - Free tier limits, hibernation cost benefits
- [Durable Objects Getting Started](https://developers.cloudflare.com/durable-objects/get-started/) - wrangler.toml configuration
- [y-webrtc bin/server.js source](local: node_modules/y-webrtc/bin/server.js) - Exact signaling protocol

### Secondary (MEDIUM confidence)
- [y-durableobjects GitHub](https://github.com/napolab/y-durableobjects) - Alternative Yjs+DO approach (WebSocket sync, not WebRTC)
- [P2PCF GitHub](https://github.com/gfodor/p2pcf) - Alternative R2-based signaling (HTTP polling)
- [Tag1 y-webrtc article](https://www.tag1.com/blog/signal-y-webrtc-part2) - Signaling concepts

### Tertiary (LOW confidence - needs validation)
- WebSocket upgrade CORS handling - Not explicitly documented, needs testing
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Cloudflare Durable Objects with WebSocket Hibernation
- Ecosystem: Existing proxy worker extension, wrangler deployment
- Patterns: y-webrtc signaling protocol, room-per-DO isolation
- Pitfalls: Hibernation vs standard API, state recovery, migration config

**Confidence breakdown:**
- Standard stack: HIGH - official Cloudflare docs, proven pattern
- Architecture: HIGH - matches existing y-webrtc protocol exactly
- Pitfalls: HIGH - documented in CF docs and community
- Code examples: HIGH - from official CF examples + verified y-webrtc source

**Research date:** 2026-01-12
**Valid until:** 2026-02-12 (30 days - Cloudflare platform stable)
</metadata>

---

*Phase: 6.1-cloudflare-worker-signaling*
*Research completed: 2026-01-12*
*Ready for planning: yes*
