---
phase: 04-crdt-state
plan: 02
type: execute
---

<objective>
Integrate CRDT state into React components with proper document lifecycle management.

Purpose: Replace useState-based userEntries with CRDT-backed state that persists and will sync in Phase 5.
Output: Puzzle entries stored in Yjs, persisted to IndexedDB, surviving page refresh and puzzle switches.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-crdt-state/04-RESEARCH.md
@.planning/phases/04-crdt-state/04-CONTEXT.md
@.planning/phases/04-crdt-state/04-01-SUMMARY.md
@src/crdt/puzzleDoc.ts
@src/crdt/puzzleStore.ts
@src/hooks/usePuzzleState.ts
@src/App.tsx
@src/types/puzzle.ts

**Tech stack available:** React 19, TypeScript, Vite, Yjs, y-indexeddb
**Established patterns:**
- Cell coordinate format: "row,col" string key
- Map<string, string> for userEntries
- Document-level keydown listener
- key={puzzle.title} for puzzle switch remounting

**Key guidance from research:**
- Decouple React from Yjs via hooks (Pattern 2)
- Use Y.Map.observe() with cleanup in useEffect
- Create new Y.Doc per puzzle, don't reuse
- Wait for persistence sync before rendering entries
- Always unobserve() in cleanup to prevent memory leaks

**Common pitfalls to avoid:**
- Not waiting for persistence sync (empty state on refresh)
- Multiple Y.Doc instances (changes don't sync)
- Forgetting observer cleanup (memory leaks)
- Mixing Yjs and React state (divergence)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useCrdtPuzzle hook for React integration</name>
  <files>src/hooks/useCrdtPuzzle.ts</files>
  <action>
Create src/hooks/useCrdtPuzzle.ts that bridges Yjs to React:

1. Hook signature: `useCrdtPuzzle(puzzleId: string)`

2. Internal state:
   - `store: PuzzleStore | null` - the current puzzle store
   - `entries: Map<string, string>` - React state mirror of Y.Map
   - `ready: boolean` - whether persistence has synced

3. Lifecycle management (useEffect on puzzleId change):
   - Create new PuzzleStore via createPuzzleStore(puzzleId)
   - Wait for store.ready promise
   - Set initial entries from store.entries.toJSON()
   - Set up Y.Map observer to sync changes to React state
   - Cleanup: unobserve and call store.destroy()

4. Observer pattern (from research):
   ```typescript
   const observer = () => {
     setEntries(new Map(store.entries.entries()))
   }
   store.entries.observe(observer)
   // cleanup: store.entries.unobserve(observer)
   ```

5. Expose methods:
   - `setEntry(row: number, col: number, value: string)` - calls entries.set(`${row},${col}`, value)
   - `clearEntry(row: number, col: number)` - calls entries.delete(`${row},${col}`)
   - `getEntry(row: number, col: number)` - returns entries.get(`${row},${col}`)

6. Return: `{ entries, ready, setEntry, clearEntry, getEntry }`

Important: Show loading state while `ready` is false to prevent flash of empty grid.

Do NOT modify usePuzzleState yet - that's Task 2.
  </action>
  <verify>
- `npm run build` succeeds
- src/hooks/useCrdtPuzzle.ts exports useCrdtPuzzle hook
- Hook handles lifecycle: create store on mount, destroy on unmount/puzzleId change
  </verify>
  <done>
- useCrdtPuzzle hook bridges Y.Map to React state
- Lifecycle management handles puzzle switching
- Observer cleanup prevents memory leaks
- Ready state available for loading UI
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate CRDT entries into usePuzzleState</name>
  <files>src/hooks/usePuzzleState.ts, src/App.tsx</files>
  <action>
Refactor usePuzzleState to use CRDT-backed entries:

1. Modify usePuzzleState signature to accept puzzleId:
   `usePuzzleState(puzzle: Puzzle, puzzleId: string)`

2. Replace useState for userEntries with useCrdtPuzzle:
   ```typescript
   const { entries: userEntries, ready, setEntry, clearEntry } = useCrdtPuzzle(puzzleId)
   ```

3. Update letter input handling (in handleKeyDown):
   - Replace `setUserEntries(prev => ...)` with `setEntry(row, col, letter)`

4. Update backspace handling:
   - Replace `newEntries.delete(cellKey)` with `clearEntry(row, col)`

5. Add `ready` to return value so App.tsx can show loading state

6. Update App.tsx:
   - Generate puzzleId from puzzle (use `puzzle.title` for now, or hash later)
   - Pass puzzleId to usePuzzleState
   - Show loading indicator while `!ready`
   - Keep existing key={puzzle.title} pattern - it will trigger hook re-init

Maintain ALL existing behavior:
- Arrow key navigation
- Auto-advance on letter entry
- Backspace dual behavior (clear or move back)
- Direction toggle on same-cell click
  </action>
  <verify>
- `npm run build` succeeds
- `npm run dev` starts without errors
- Typing letters works (appears in grid)
- Backspace works (clears or moves back)
- Arrow navigation works
  </verify>
  <done>
- usePuzzleState uses CRDT-backed entries
- All keyboard behaviors preserved
- App.tsx handles loading state
- Build and dev server work
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>CRDT-backed puzzle state with IndexedDB persistence</what-built>
  <how-to-verify>
1. Run: `npm run dev`
2. Open: http://localhost:5173
3. Type several letters into the puzzle grid
4. **Refresh the page** (F5 or Cmd+R)
5. Verify: Your entered letters should still be there (persistence works)
6. Import a different puzzle (use file picker or downloader)
7. Type some letters in the new puzzle
8. Refresh again
9. Verify: New puzzle has its entries, original puzzle entries are separate
10. Switch back to original puzzle (import sample or reload without file)
11. Verify: Original entries are preserved

Also verify:
- Typing feels instant (no perceptible delay)
- No console errors related to Yjs or IndexedDB
- Brief loading state visible on initial load (may be very fast)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes (or only pre-existing warnings)
- [ ] Entries persist across page refresh
- [ ] Different puzzles have separate entry storage
- [ ] All keyboard behaviors work as before
- [ ] No console errors
</verification>

<success_criteria>

- CRDT entries integrated into puzzle state
- IndexedDB persistence verified working
- Puzzle switching creates separate storage
- All existing keyboard behaviors preserved
- Phase 4 complete - ready for Phase 5 (P2P networking)
</success_criteria>

<output>
After completion, create `.planning/phases/04-crdt-state/04-02-SUMMARY.md` following the summary template.

Include in summary:
- Note that entries are now CRDT-backed and ready for multiplayer sync
- Document the puzzleId derivation approach
- Note any deviations from the Yjs patterns in research doc
</output>
