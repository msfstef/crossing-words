---
phase: 07-check-reveal
plan: 03
type: execute
---

<objective>
Create toolbar UI for check/reveal actions and comprehensive Playwright tests for all verification behavior.

Purpose: Complete the user-facing check/reveal feature with accessible UI and verify all functionality via automated e2e tests.
Output: Toolbar component integrated into App, auto-check mode, comprehensive Playwright test suite for check/reveal.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-check-reveal/07-CONTEXT.md
@.planning/phases/07-check-reveal/07-RESEARCH.md
@.planning/phases/07-check-reveal/07-01-SUMMARY.md
@.planning/phases/07-check-reveal/07-02-SUMMARY.md

# Key files:
@src/App.tsx
@src/App.css
@src/hooks/useVerification.ts
@e2e/collaboration.spec.ts

**Tech stack available:** react, playwright
**Established patterns:**
- Toolbar/header UI in App.tsx
- Playwright tests in e2e/ directory
- Toast notifications via sonner

**Prior plans provide:**
- useVerification hook with all check/reveal actions
- verifiedCells, errorCells from useCrdtPuzzle
- Grid with verified/error styling
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Toolbar component with Check/Reveal menus</name>
  <files>src/components/Toolbar.tsx, src/components/Toolbar.css</files>
  <action>
Create a Toolbar component with dropdown menus for Check and Reveal actions:

**Toolbar.tsx:**
```typescript
import { useState, useRef, useEffect } from 'react';
import './Toolbar.css';

interface ToolbarProps {
  onCheckLetter: () => void;
  onCheckWord: () => void;
  onCheckPuzzle: () => void;
  onRevealLetter: () => void;
  onRevealWord: () => void;
  onRevealPuzzle: () => void;
  autoCheckEnabled: boolean;
  onAutoCheckToggle: () => void;
}

export function Toolbar({
  onCheckLetter, onCheckWord, onCheckPuzzle,
  onRevealLetter, onRevealWord, onRevealPuzzle,
  autoCheckEnabled, onAutoCheckToggle,
}: ToolbarProps) {
  const [checkMenuOpen, setCheckMenuOpen] = useState(false);
  const [revealMenuOpen, setRevealMenuOpen] = useState(false);
  const checkRef = useRef<HTMLDivElement>(null);
  const revealRef = useRef<HTMLDivElement>(null);

  // Close menus when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (checkRef.current && !checkRef.current.contains(event.target as Node)) {
        setCheckMenuOpen(false);
      }
      if (revealRef.current && !revealRef.current.contains(event.target as Node)) {
        setRevealMenuOpen(false);
      }
    }
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="toolbar">
      <div className="toolbar-group" ref={checkRef}>
        <button
          className="toolbar-button"
          onClick={() => { setCheckMenuOpen(!checkMenuOpen); setRevealMenuOpen(false); }}
          aria-expanded={checkMenuOpen}
          aria-haspopup="true"
          data-testid="check-button"
        >
          Check ▾
        </button>
        {checkMenuOpen && (
          <div className="toolbar-menu" role="menu">
            <button
              role="menuitem"
              onClick={() => { onCheckLetter(); setCheckMenuOpen(false); }}
              data-testid="check-letter"
            >
              Letter
            </button>
            <button
              role="menuitem"
              onClick={() => { onCheckWord(); setCheckMenuOpen(false); }}
              data-testid="check-word"
            >
              Word
            </button>
            <button
              role="menuitem"
              onClick={() => { onCheckPuzzle(); setCheckMenuOpen(false); }}
              data-testid="check-puzzle"
            >
              Puzzle
            </button>
          </div>
        )}
      </div>

      <div className="toolbar-group" ref={revealRef}>
        <button
          className="toolbar-button"
          onClick={() => { setRevealMenuOpen(!revealMenuOpen); setCheckMenuOpen(false); }}
          aria-expanded={revealMenuOpen}
          aria-haspopup="true"
          data-testid="reveal-button"
        >
          Reveal ▾
        </button>
        {revealMenuOpen && (
          <div className="toolbar-menu" role="menu">
            <button
              role="menuitem"
              onClick={() => { onRevealLetter(); setRevealMenuOpen(false); }}
              data-testid="reveal-letter"
            >
              Letter
            </button>
            <button
              role="menuitem"
              onClick={() => { onRevealWord(); setRevealMenuOpen(false); }}
              data-testid="reveal-word"
            >
              Word
            </button>
            <button
              role="menuitem"
              onClick={() => { onRevealPuzzle(); setRevealMenuOpen(false); }}
              data-testid="reveal-puzzle"
            >
              Puzzle
            </button>
          </div>
        )}
      </div>

      <label className="toolbar-toggle" data-testid="auto-check-toggle">
        <input
          type="checkbox"
          checked={autoCheckEnabled}
          onChange={onAutoCheckToggle}
        />
        <span>Auto-check</span>
      </label>
    </div>
  );
}
```

**Toolbar.css:**
```css
.toolbar {
  display: flex;
  gap: 12px;
  align-items: center;
  padding: 8px 16px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.toolbar-group {
  position: relative;
}

.toolbar-button {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #ffffff;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.toolbar-button:hover {
  background: rgba(255, 255, 255, 0.15);
}

.toolbar-menu {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 4px;
  background: #2d2d4a;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  overflow: hidden;
  z-index: 100;
  min-width: 100px;
}

.toolbar-menu button {
  display: block;
  width: 100%;
  text-align: left;
  padding: 10px 16px;
  background: none;
  border: none;
  color: #ffffff;
  cursor: pointer;
  font-size: 14px;
}

.toolbar-menu button:hover {
  background: rgba(255, 255, 255, 0.1);
}

.toolbar-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #ffffff;
  font-size: 14px;
  cursor: pointer;
  user-select: none;
}

.toolbar-toggle input {
  width: 16px;
  height: 16px;
  cursor: pointer;
}
```

Key features:
- Data-testid attributes for Playwright testing
- ARIA attributes for accessibility
- Click-outside-to-close behavior
- Dark theme matching existing UI
  </action>
  <verify>`npm run build` compiles without errors</verify>
  <done>Toolbar component created with Check/Reveal dropdown menus and auto-check toggle</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Toolbar and auto-check into App</name>
  <files>src/App.tsx, src/App.css</files>
  <action>
Wire up Toolbar to App with verification state and auto-check functionality:

1. Import Toolbar component
2. Import useVerification hook
3. Add auto-check state (local useState - personal preference, not synced)
4. Wire up useVerification with puzzle state
5. Add auto-check effect that checks cell on entry change
6. Render Toolbar in header area

**Key additions to App.tsx:**

```typescript
import { Toolbar } from './components/Toolbar';
import { useVerification } from './hooks/useVerification';

// Inside component:
const [autoCheckEnabled, setAutoCheckEnabled] = useState(false);

// Get verification maps from useCrdtPuzzle (via usePuzzleState or direct)
// Wire up useVerification hook with these

const {
  checkLetter, checkWord, checkPuzzle,
  revealLetter, revealWord, revealPuzzle,
} = useVerification({
  puzzle,
  entries: userEntries,
  entriesMap,
  verifiedMap,
  errorsMap,
  doc,
  currentWord,
  selectedCell,
});

// Auto-check on entry change (when enabled)
useEffect(() => {
  if (!autoCheckEnabled || !selectedCell) return;

  const key = `${selectedCell.row},${selectedCell.col}`;
  const entry = userEntries.get(key);

  if (entry && !verifiedCells.has(key)) {
    // Check the cell that was just typed
    const cell = puzzle.grid[selectedCell.row][selectedCell.col];
    if (entry !== cell.letter) {
      errorsMap.set(key, true);
    } else {
      errorsMap.delete(key);
    }
  }
}, [autoCheckEnabled, selectedCell, userEntries, puzzle, verifiedCells, errorsMap]);
```

**Render Toolbar in header:**
```tsx
<header className="app-header">
  {/* existing header content */}
  {puzzle && (
    <Toolbar
      onCheckLetter={checkLetter}
      onCheckWord={checkWord}
      onCheckPuzzle={checkPuzzle}
      onRevealLetter={revealLetter}
      onRevealWord={revealWord}
      onRevealPuzzle={revealPuzzle}
      autoCheckEnabled={autoCheckEnabled}
      onAutoCheckToggle={() => setAutoCheckEnabled(!autoCheckEnabled)}
    />
  )}
</header>
```

**Note:** Auto-check is intentionally local-only (not synced via CRDT) as it's a personal preference that doesn't affect collaborators' experience. Each player can choose whether they want live error feedback.
  </action>
  <verify>`npm run build` compiles, app shows Toolbar when puzzle loaded</verify>
  <done>App.tsx has Toolbar integrated with all verification actions, auto-check toggle works</done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive Playwright e2e tests for check/reveal</name>
  <files>e2e/check-reveal.spec.ts</files>
  <action>
Create comprehensive Playwright tests covering all check/reveal functionality:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Check/Reveal Functionality', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    // Wait for sample puzzle to load (or load one)
    await page.waitForSelector('.crossword-grid');
  });

  test.describe('Check Letter', () => {
    test('marks correct letter as verified with green dot', async ({ page }) => {
      // Click first cell
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      // Get the solution letter (from data attribute or puzzle state)
      // Type the correct letter
      await page.keyboard.type('A'); // Assume first letter is 'A' for sample puzzle

      // Click Check > Letter
      await page.getByTestId('check-button').click();
      await page.getByTestId('check-letter').click();

      // Verify cell has verified class and green dot
      await expect(firstCell).toHaveClass(/cell--verified/);
    });

    test('marks incorrect letter as error with red background', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      // Type wrong letter
      await page.keyboard.type('Z');

      await page.getByTestId('check-button').click();
      await page.getByTestId('check-letter').click();

      await expect(firstCell).toHaveClass(/cell--error/);
    });

    test('error clears when letter is changed', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();
      await page.keyboard.type('Z');

      await page.getByTestId('check-button').click();
      await page.getByTestId('check-letter').click();
      await expect(firstCell).toHaveClass(/cell--error/);

      // Change the letter
      await firstCell.click();
      await page.keyboard.type('A');

      await expect(firstCell).not.toHaveClass(/cell--error/);
    });
  });

  test.describe('Check Word', () => {
    test('checks all letters in current word', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      // Type a few letters
      await page.keyboard.type('ABC');

      await page.getByTestId('check-button').click();
      await page.getByTestId('check-word').click();

      // Should have mix of verified and error cells
      const cells = page.locator('.cell--in-word, .cell--selected');
      await expect(cells.first()).toHaveClass(/cell--(verified|error)/);
    });
  });

  test.describe('Reveal Letter', () => {
    test('reveals correct letter and marks as verified', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      await page.getByTestId('reveal-button').click();
      await page.getByTestId('reveal-letter').click();

      await expect(firstCell).toHaveClass(/cell--verified/);
      // Cell should have a letter now
      await expect(firstCell.locator('.cell-letter')).not.toBeEmpty();
    });

    test('revealed cell is locked - cannot be deleted', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      await page.getByTestId('reveal-button').click();
      await page.getByTestId('reveal-letter').click();

      const letterBefore = await firstCell.locator('.cell-letter').textContent();

      // Try to delete
      await firstCell.click();
      await page.keyboard.press('Backspace');

      const letterAfter = await firstCell.locator('.cell-letter').textContent();
      expect(letterAfter).toBe(letterBefore);
    });
  });

  test.describe('Reveal Word', () => {
    test('reveals all letters in current word', async ({ page }) => {
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      await page.getByTestId('reveal-button').click();
      await page.getByTestId('reveal-word').click();

      // All cells in word should be verified
      const wordCells = page.locator('.cell--verified');
      await expect(wordCells).toHaveCount(await wordCells.count());
    });
  });

  test.describe('Verified Cell Navigation', () => {
    test('typing skips verified cells', async ({ page }) => {
      const cells = page.locator('.crossword-cell:not(.cell--black)');
      const firstCell = cells.first();
      await firstCell.click();

      // Reveal first cell
      await page.getByTestId('reveal-button').click();
      await page.getByTestId('reveal-letter').click();

      // Type a letter - should go to second cell (skipping first)
      await page.keyboard.type('X');

      // Second cell should have the letter, not first
      const secondCell = cells.nth(1);
      await expect(secondCell.locator('.cell-letter')).toHaveText('X');
    });
  });

  test.describe('Auto-Check Mode', () => {
    test('toggles auto-check mode', async ({ page }) => {
      const toggle = page.getByTestId('auto-check-toggle');
      const checkbox = toggle.locator('input');

      await expect(checkbox).not.toBeChecked();
      await toggle.click();
      await expect(checkbox).toBeChecked();
    });

    test('auto-check shows errors as you type', async ({ page }) => {
      // Enable auto-check
      await page.getByTestId('auto-check-toggle').click();

      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();

      // Type wrong letter
      await page.keyboard.type('Z');

      // Should immediately show error (no manual check needed)
      await expect(firstCell).toHaveClass(/cell--error/);
    });
  });

  test.describe('Check/Reveal Puzzle', () => {
    test('check puzzle marks all cells', async ({ page }) => {
      // Fill some cells
      const firstCell = page.locator('.crossword-cell:not(.cell--black)').first();
      await firstCell.click();
      await page.keyboard.type('ABCDE');

      await page.getByTestId('check-button').click();
      await page.getByTestId('check-puzzle').click();

      // Should have verified and/or error cells
      const markedCells = page.locator('.cell--verified, .cell--error');
      const count = await markedCells.count();
      expect(count).toBeGreaterThan(0);
    });

    test('reveal puzzle fills all cells', async ({ page }) => {
      await page.getByTestId('reveal-button').click();
      await page.getByTestId('reveal-puzzle').click();

      // All non-black cells should be verified
      const whiteCells = page.locator('.crossword-cell:not(.cell--black)');
      const verifiedCells = page.locator('.cell--verified');

      const whiteCount = await whiteCells.count();
      const verifiedCount = await verifiedCells.count();
      expect(verifiedCount).toBe(whiteCount);
    });
  });
});

test.describe('P2P Verification Sync', () => {
  test('verified state syncs between peers', async ({ browser }) => {
    // Create two browser contexts
    const context1 = await browser.newContext();
    const context2 = await browser.newContext();
    const page1 = await context1.newPage();
    const page2 = await context2.newPage();

    // Load app in first peer
    await page1.goto('/');
    await page1.waitForSelector('.crossword-grid');

    // Get share URL
    await page1.getByText('Share').click();
    await page1.waitForSelector('[data-testid="share-dialog"]', { timeout: 5000 }).catch(() => {});
    const shareUrl = await page1.evaluate(() => navigator.clipboard.readText()).catch(() => null);

    if (!shareUrl) {
      test.skip();
      return;
    }

    // Join from second peer
    await page2.goto(shareUrl);
    await page2.waitForSelector('.crossword-grid');

    // First peer reveals a letter
    const firstCell = page1.locator('.crossword-cell:not(.cell--black)').first();
    await firstCell.click();
    await page1.getByTestId('reveal-button').click();
    await page1.getByTestId('reveal-letter').click();

    // Second peer should see verified cell
    const syncedCell = page2.locator('.crossword-cell:not(.cell--black)').first();
    await expect(syncedCell).toHaveClass(/cell--verified/, { timeout: 5000 });

    await context1.close();
    await context2.close();
  });
});
```

This test file covers:
- Check letter (correct → verified, incorrect → error)
- Error clears on change
- Check word
- Reveal letter/word (locked after reveal)
- Verified cell navigation skip
- Auto-check mode
- Check/reveal puzzle
- P2P sync of verification state
  </action>
  <verify>Run tests: `npx playwright test e2e/check-reveal.spec.ts --reporter=line`</verify>
  <done>Comprehensive e2e tests for check/reveal in e2e/check-reveal.spec.ts</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete check/reveal feature with toolbar UI, auto-check mode, and Playwright tests</what-built>
  <how-to-verify>
    1. Run: `npm run dev`
    2. Visit: http://localhost:5173
    3. Load sample puzzle or download one
    4. Test Check functionality:
       - Type some letters
       - Click Check > Letter - correct letters get green dot, wrong get red background
       - Click Check > Word - checks entire current word
       - Verify red error clears when you fix the letter
    5. Test Reveal functionality:
       - Click Reveal > Letter - fills in correct letter with green dot
       - Try to delete revealed letter (should fail - cell is locked)
       - Click Reveal > Word - fills entire word
    6. Test navigation:
       - Reveal some letters
       - Type new letters - cursor should skip over revealed cells
    7. Test Auto-check:
       - Toggle Auto-check on
       - Type wrong letters - should show red immediately
       - Type correct letters - no error shown
    8. Run Playwright tests: `npx playwright test e2e/check-reveal.spec.ts`
    9. Verify P2P sync (optional):
       - Open two browser windows
       - Share session
       - Reveal letter in one window
       - Verify it appears as verified in the other
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Toolbar renders with Check/Reveal menus
- [ ] Auto-check toggle works
- [ ] All Playwright tests pass: `npx playwright test e2e/check-reveal.spec.ts`
- [ ] Human verification approves UX
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Playwright tests pass
- Human verification approved
- Phase 7 complete - Check/Reveal fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/07-check-reveal/07-03-SUMMARY.md`:

# Phase 7 Plan 3: Toolbar & Playwright Tests Summary

**[Substantive one-liner]**

## Accomplishments

- Toolbar component with Check/Reveal dropdown menus
- Auto-check mode for live error feedback
- Comprehensive Playwright e2e test suite

## Files Created/Modified

- `src/components/Toolbar.tsx` - Check/Reveal menus
- `src/components/Toolbar.css` - Toolbar styling
- `src/App.tsx` - Toolbar integration
- `e2e/check-reveal.spec.ts` - E2E tests

## Decisions Made

- Auto-check is local-only (personal preference, not synced)

## Issues Encountered

[Any issues]

## Next Phase Readiness

- Phase 7: Check/Reveal complete
- Ready for Phase 8: Polish & PWA
</output>
