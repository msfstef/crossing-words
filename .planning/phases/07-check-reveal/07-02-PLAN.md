---
phase: 07-check-reveal
plan: 02
type: execute
---

<objective>
Integrate verification state into the grid and navigation system.

Purpose: Make verification visible (CSS classes for verified/error cells) and functional (verified cells lock and are skipped in navigation).
Output: CrosswordGrid with verified/error styling, navigation that skips verified cells, error auto-clear on entry change.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-check-reveal/07-CONTEXT.md
@.planning/phases/07-check-reveal/07-RESEARCH.md
@.planning/phases/07-check-reveal/07-01-SUMMARY.md

# Key files:
@src/components/CrosswordGrid.tsx
@src/components/CrosswordGrid.css
@src/hooks/usePuzzleState.ts
@src/hooks/useCrdtPuzzle.ts

**Tech stack available:** yjs, react, CSS
**Established patterns:**
- CSS class composition for cell states
- findNextCellWithClue for navigation
- Observer pattern for entry changes

**Prior plan provides:**
- getVerifiedMap(), getErrorsMap() from puzzleDoc
- useVerification hook with check/reveal actions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verification CSS classes to CrosswordGrid</name>
  <files>src/components/CrosswordGrid.css, src/components/CrosswordGrid.tsx</files>
  <action>
**CSS additions to CrosswordGrid.css:**

```css
/* Verified cell - subtle green indicator, visually "locked" */
.cell--verified {
  position: relative;
}

.cell--verified::after {
  content: '';
  position: absolute;
  bottom: 2px;
  right: 2px;
  width: 6px;
  height: 6px;
  background-color: #4caf50;
  border-radius: 50%;
  opacity: 0.8;
}

/* Error cell - red highlight for incorrect entry */
.cell--error {
  background-color: rgba(244, 67, 54, 0.25) !important;
}

.cell--error .cell-letter {
  color: #f44336;
}

/* Subtle shake animation on error (triggers when class added) */
@keyframes cell-shake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-2px); }
  40% { transform: translateX(2px); }
  60% { transform: translateX(-2px); }
  80% { transform: translateX(2px); }
}

.cell--error {
  animation: cell-shake 0.3s ease-in-out;
}
```

**TSX changes to CrosswordGrid.tsx:**

Add new props to interface:
```typescript
interface CrosswordGridProps {
  // ... existing props
  /** Set of verified cell keys ("row,col") */
  verifiedCells?: Set<string>;
  /** Set of error cell keys ("row,col") */
  errorCells?: Set<string>;
}
```

Add to component signature:
```typescript
export function CrosswordGrid({
  // ... existing
  verifiedCells = new Set(),
  errorCells = new Set(),
}: CrosswordGridProps) {
```

Update cellClasses computation:
```typescript
const isVerified = verifiedCells.has(key);
const hasError = errorCells.has(key);

const cellClasses = [
  "crossword-cell",
  cell.isBlack ? "cell--black" : "cell--white",
  isSelected ? "cell--selected" : "",
  inWord && !isSelected ? "cell--in-word" : "",
  hasCollaboratorHighlight ? "cell--collaborator" : "",
  isVerified ? "cell--verified" : "",
  hasError ? "cell--error" : "",
]
  .filter(Boolean)
  .join(" ");
```

The cell--verified and cell--error classes are applied additively - a cell can have both verification status and be selected/in-word for full visual feedback.
  </action>
  <verify>Visual inspection: load app, styles should compile without errors</verify>
  <done>CrosswordGrid accepts verifiedCells and errorCells props, applies cell--verified and cell--error CSS classes</done>
</task>

<task type="auto">
  <name>Task 2: Integrate verified/error state in useCrdtPuzzle</name>
  <files>src/hooks/useCrdtPuzzle.ts</files>
  <action>
Extend useCrdtPuzzle to expose verified and error state from CRDT:

1. Import getVerifiedMap, getErrorsMap from puzzleDoc
2. Create verified and errors state using useSyncExternalStore pattern (same as entries)
3. Add observer to clear error when entry changes at that position
4. Return verifiedCells and errorCells as Sets, plus the raw maps and doc for useVerification

**Key additions:**

```typescript
// Get verified and errors maps
const verifiedMap = getVerifiedMap(docRef.current);
const errorsMap = getErrorsMap(docRef.current);

// Create snapshots for verified and errors (same pattern as entries)
const getVerifiedSnapshot = useCallback(() => {
  return new Set(verifiedMap.keys());
}, []);

const getErrorsSnapshot = useCallback(() => {
  return new Set(errorsMap.keys());
}, []);

const subscribeVerified = useCallback((callback: () => void) => {
  verifiedMap.observe(callback);
  return () => verifiedMap.unobserve(callback);
}, []);

const subscribeErrors = useCallback((callback: () => void) => {
  errorsMap.observe(callback);
  return () => errorsMap.unobserve(callback);
}, []);

const verifiedCells = useSyncExternalStore(subscribeVerified, getVerifiedSnapshot);
const errorCells = useSyncExternalStore(subscribeErrors, getErrorsSnapshot);
```

**Auto-clear error on entry change:**
Add to the entries observer:
```typescript
entriesMap.observe((event) => {
  event.changes.keys.forEach((change, key) => {
    // When entry changes, clear any error at that position
    if (errorsMap.has(key)) {
      errorsMap.delete(key);
    }
  });
});
```

**Return additions:**
```typescript
return {
  // ... existing
  verifiedCells,
  errorCells,
  verifiedMap,
  errorsMap,
  doc: docRef.current,
};
```

This makes verified/error state available to components and ensures errors clear when user fixes a cell.
  </action>
  <verify>`npm run build` compiles without errors</verify>
  <done>useCrdtPuzzle returns verifiedCells, errorCells Sets and exposes verifiedMap, errorsMap, doc for useVerification</done>
</task>

<task type="auto">
  <name>Task 3: Modify navigation to skip verified cells</name>
  <files>src/hooks/usePuzzleState.ts</files>
  <action>
Modify usePuzzleState to skip verified cells during auto-advance and block editing verified cells.

1. Get verifiedCells from useCrdtPuzzle (destructure the new return value)

2. Modify findNextCellWithClue to skip verified cells:
```typescript
const findNextCellWithClue = useCallback(
  (fromRow: number, fromCol: number, deltaRow: number, deltaCol: number, dir: 'across' | 'down') => {
    let row = fromRow + deltaRow;
    let col = fromCol + deltaCol;

    while (row >= 0 && row < puzzle.height && col >= 0 && col < puzzle.width) {
      const key = `${row},${col}`;

      // Skip black cells
      if (puzzle.grid[row][col].isBlack) {
        row += deltaRow;
        col += deltaCol;
        continue;
      }

      // Skip verified cells (NEW)
      if (verifiedCells.has(key)) {
        row += deltaRow;
        col += deltaCol;
        continue;
      }

      // Check for clue in direction
      if (findClueForCell(row, col, dir)) {
        return { row, col };
      }

      row += deltaRow;
      col += deltaCol;
    }
    return null;
  },
  [puzzle, findClueForCell, verifiedCells]
);
```

3. Modify handleKeyDown to prevent editing verified cells:
```typescript
// In letter input section:
if (/^[a-zA-Z]$/.test(key)) {
  event.preventDefault();
  const cellKey = `${selectedCell.row},${selectedCell.col}`;

  // Block editing verified cells (NEW)
  if (verifiedCells.has(cellKey)) {
    // Just advance without editing
    autoAdvance(selectedCell.row, selectedCell.col);
    return;
  }

  setEntry(selectedCell.row, selectedCell.col, key.toUpperCase());
  autoAdvance(selectedCell.row, selectedCell.col);
  return;
}

// In backspace section:
if (key === 'Backspace') {
  event.preventDefault();
  const cellKey = `${selectedCell.row},${selectedCell.col}`;

  // Block deleting verified cells (NEW)
  if (verifiedCells.has(cellKey)) {
    // Find previous non-verified cell and move there
    const deltaRow = direction === 'down' ? -1 : 0;
    const deltaCol = direction === 'across' ? -1 : 0;
    // ... navigate back, skipping verified cells
    return;
  }
  // ... existing backspace logic
}
```

4. Update findFirstCellInRowWithClue and findFirstCellInColWithClue to also skip verified cells when wrapping.

5. Add verifiedCells to the return interface for downstream components.

Key behavior:
- Typing on verified cell: skip to next unverified (silent, no feedback needed)
- Backspace on verified cell: find previous unverified cell (user feedback via no-op)
- Auto-advance: skips all verified cells
  </action>
  <verify>`npm run build` compiles without errors</verify>
  <done>Navigation skips verified cells, typing/backspace blocked on verified cells, verifiedCells exposed from hook</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] CrosswordGrid has verified/error CSS classes applied
- [ ] useCrdtPuzzle exposes verifiedCells, errorCells, verifiedMap, errorsMap, doc
- [ ] Navigation skips verified cells
- [ ] Editing blocked on verified cells
- [ ] Errors clear when entry changes
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Grid visually shows verified (green dot) and error (red background) states
- Verified cells are locked and skipped in navigation
</success_criteria>

<output>
After completion, create `.planning/phases/07-check-reveal/07-02-SUMMARY.md`
</output>
