---
phase: 06-collaboration
plan: 04
type: execute
---

<objective>
Implement timeline collision detection and merge/fork join flow for users with existing progress.

Purpose: Respect existing work-in-progress while enabling collaboration - the timeline model core to this phase.
Output: Existing timeline detection, JoinDialog with merge/save-new choice, Yjs document merge implementation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-collaboration/06-CONTEXT.md
@.planning/phases/06-collaboration/06-RESEARCH.md
@.planning/phases/06-collaboration/06-01-PLAN.md
@.planning/phases/06-collaboration/06-02-PLAN.md
@.planning/phases/06-collaboration/06-03-PLAN.md

@src/crdt/puzzleStore.ts
@src/crdt/puzzleDoc.ts
@src/lib/puzzleStorage.ts
@src/App.tsx

**Tech stack available:** Yjs Y.applyUpdate, Y.encodeStateAsUpdate for merge
**Established patterns:** IndexedDB for puzzle storage, PuzzleStore per puzzle

**From context vision:**
- "If the person joining has an in-progress timeline for this puzzle: offer a choice to either merge (combining progress, then discarding their separate timeline) or save the shared timeline as a new one (keeping both)"
- "If they don't have the puzzle, or have completed it: instant drop-in, no friction"
- "Merge conflict resolution: checked/solved cells always win, otherwise the shared timeline's answer wins"

**From research:**
- Document merge: Y.applyUpdate(localDoc, remoteUpdate) merges states
- Fork: Create new Y.Doc and apply remote update to it

**Key insight:** The timeline ID determines the "room" for P2P sync. Same puzzleId + different timelineId = different collaborative sessions. When user joins via link, we need to check if they have local progress for that puzzle (different timeline) and offer choice.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timeline storage utilities</name>
  <files>src/collaboration/timelineStorage.ts, src/lib/puzzleStorage.ts</files>
  <action>
Create src/collaboration/timelineStorage.ts with:

1. getLocalTimelineForPuzzle(puzzleId: string): Promise<string | null>
   - Check if user has existing progress for this puzzle
   - Look in IndexedDB for any stored entries for this puzzleId
   - Return the timeline ID if progress exists, null if not
   - For now, puzzles without explicit timeline = "local" timeline ID

2. hasLocalProgress(puzzleId: string): Promise<boolean>
   - Quick check if any entries exist for puzzleId in local storage
   - Used to determine if merge dialog is needed

3. saveTimelineMapping(puzzleId: string, timelineId: string): Promise<void>
   - Store which timeline the user is currently on for this puzzle
   - Use localStorage or IndexedDB key: `timeline:${puzzleId}` = timelineId

4. getCurrentTimeline(puzzleId: string): string | null
   - Synchronous check of current timeline from localStorage
   - Returns null if never set (first time or local-only)

Update src/lib/puzzleStorage.ts if needed to support timeline metadata.

Storage model:
- IndexedDB: Puzzle entries stored with puzzleId (existing)
- localStorage: timeline:${puzzleId} â†’ current timelineId
- When sharing, timelineId gets generated and stored
- When joining, shared timelineId replaces/merges with local
  </action>
  <verify>npm run build passes, can store and retrieve timeline mappings</verify>
  <done>Timeline storage utilities working, can detect if local progress exists for a puzzle</done>
</task>

<task type="auto">
  <name>Task 2: Create JoinDialog for merge/fork choice</name>
  <files>src/components/JoinDialog.tsx, src/components/JoinDialog.css</files>
  <action>
Create JoinDialog component:
- Props:
  - isOpen: boolean
  - puzzleTitle: string
  - localEntryCount: number (show "You have X letters filled in locally")
  - onMerge: () => void
  - onSaveAsNew: () => void
  - onCancel: () => void
- Render modal dialog explaining the situation:
  - Heading: "Join collaborative session?"
  - Message: "You have progress on this puzzle ({localEntryCount} letters). What would you like to do?"
  - Options as buttons:
    1. "Merge Progress" - Combine your work with the shared session (recommended)
    2. "Start Fresh" - Join the shared session without your local progress
    3. "Cancel" - Stay with your local progress, don't join
- Style similar to ShareDialog (dark theme, centered)

CSS (JoinDialog.css):
- Modal overlay matching ShareDialog
- Clear button hierarchy (primary: Merge, secondary: Start Fresh, tertiary: Cancel)
- Explanatory text for each option
  </action>
  <verify>npm run build passes, JoinDialog renders with all options, click handlers work</verify>
  <done>JoinDialog component ready for integration, shows merge/start-fresh/cancel options</done>
</task>

<task type="auto">
  <name>Task 3: Implement join flow with timeline merge</name>
  <files>src/App.tsx, src/crdt/puzzleStore.ts</files>
  <action>
Update App.tsx join flow:

1. When URL has timeline param (user joining via share link):
   - Check hasLocalProgress(puzzleId)
   - If no local progress: proceed directly, set timelineId from URL
   - If has local progress AND timeline differs from stored:
     - Show JoinDialog
     - On Merge:
       - Connect to shared room, let Yjs merge states automatically (both docs connect to same room)
       - Update stored timeline to shared one
       - Close dialog
     - On Start Fresh:
       - Clear local entries for this puzzle (or just switch timeline without merge)
       - Connect to shared room
       - Update stored timeline
     - On Cancel:
       - Remove timeline param from URL (history.replaceState)
       - Stay local

2. Add state: joinDialogState: { isOpen: boolean, pendingTimelineId: string | null }

3. Flow logic:
```typescript
useEffect(() => {
  if (sharedTimelineId && puzzle) {
    const localTimeline = getCurrentTimeline(puzzleId);
    if (localTimeline && localTimeline !== sharedTimelineId) {
      hasLocalProgress(puzzleId).then(hasProgress => {
        if (hasProgress) {
          setJoinDialogState({ isOpen: true, pendingTimelineId: sharedTimelineId });
        } else {
          // No conflict, just join
          setActiveTimelineId(sharedTimelineId);
        }
      });
    } else {
      setActiveTimelineId(sharedTimelineId);
    }
  }
}, [sharedTimelineId, puzzle, puzzleId]);
```

Update puzzleStore.ts (if needed):
- The Yjs merge happens automatically when two clients connect to same room
- For "merge" choice, we just need both states to sync via WebRTC
- The "checked entries win" conflict resolution is a Phase 7 concern (check/reveal)

Key realization: Yjs CRDT handles merge automatically when docs connect. The "merge" choice just means connecting to the shared room with existing local state. The "start fresh" means clearing local state before connecting.
  </action>
  <verify>npm run build passes, joining with existing progress shows dialog, merge and start-fresh work correctly</verify>
  <done>Join flow detects existing progress, shows choice dialog, merge connects to room with local state intact, start fresh clears local state first</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete timeline join flow with merge/fork choice</what-built>
  <how-to-verify>
    1. Run: npm run dev (and signaling server)
    2. Window A: Open app, load puzzle, fill in some letters (e.g., 5 letters), click Share, copy link
    3. Window B: Open app fresh (different browser/profile or clear localStorage)
    4. Window B: Paste shared link
    5. Verify: Window B joins instantly (no dialog, no local progress)
    6. Window B: Fill in a few different letters
    7. Window C: Open app, load SAME puzzle, fill in different letters locally
    8. Window C: Paste the shared link
    9. Verify: JoinDialog appears showing local progress count
    10. Test "Merge Progress": Letters from both Window C local and shared session should combine
    11. Repeat test with "Start Fresh": Window C's local letters should be replaced with shared session's
    12. Repeat test with "Cancel": Window C stays local, doesn't join shared session
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] User with no local progress joins instantly
- [ ] User with local progress sees JoinDialog
- [ ] Merge option combines local and shared state
- [ ] Start Fresh option replaces local with shared
- [ ] Cancel option stays local
- [ ] Human verification checkpoint approved
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Human verification approved
- Timeline model working correctly
- Phase 6: Collaboration complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-collaboration/06-04-SUMMARY.md` with:
- Accomplishments: Timeline storage, JoinDialog, merge/fork flow working
- Files Created/Modified
- Decisions Made (merge strategy, UX choices)
- Issues Encountered (if any)
- Next Step: "Phase 6 complete, ready for Phase 7: Check/Reveal"
</output>
