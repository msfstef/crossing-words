---
phase: 3.1-puzzle-downloader
plan: 01
type: execute
---

<objective>
Create Cloudflare Worker CORS proxy for fetching crossword puzzles from external sources.

Purpose: Enable browser-based puzzle fetching by proxying requests through Cloudflare Workers with proper CORS headers. Most puzzle sources don't serve CORS headers, making direct browser fetch impossible.

Output: Deployed Cloudflare Worker at `crossing-words-proxy.workers.dev` that proxies puzzle requests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3.1-automatic-downloader-from-remote-sources-with-picker-for-source-and-day/3.1-RESEARCH.md

**Tech stack available:**
- Vite + React + TypeScript
- xd-crossword-tools for parsing
- vite-plugin-pwa

**Established patterns:**
- css-grid-layout, map-based-state
- hidden-file-input (FilePicker)
- error-toast-auto-dismiss

**From RESEARCH.md - Don't hand-roll:**
- CORS proxying → Use Cloudflare Worker (free, global, no maintenance)
- URL patterns per source → Reference xword-dl patterns

**From RESEARCH.md - Pitfalls to avoid:**
- Direct browser fetch to puzzle sources (CORS blocks)
- Hardcoding dates in URL strings (use date-fns)
- Storing user credentials in proxy (never handle auth server-side)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cloudflare Worker project</name>
  <files>proxy/package.json, proxy/wrangler.toml, proxy/src/index.ts, proxy/tsconfig.json</files>
  <action>
Create a new `proxy/` directory at project root for the Cloudflare Worker.

Initialize with:
```bash
cd proxy && npm init -y
```

Create `wrangler.toml`:
```toml
name = "crossing-words-proxy"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[vars]
ALLOWED_ORIGINS = "*"
```

Create `tsconfig.json` with ES2022 target, module NodeNext.

Create `src/index.ts` with a CORS proxy that:
1. Handles OPTIONS preflight with CORS headers (Access-Control-Allow-Origin: *, Methods: GET/POST/OPTIONS, Headers: Content-Type)
2. Accepts POST to `/puzzle` with JSON body `{ source: string, date: string }`
3. Maps source ID to URL pattern (start with Universal only for testing)
4. Fetches upstream puzzle with User-Agent: "CrossingWords/1.0"
5. Returns puzzle bytes with CORS headers and Content-Type: application/octet-stream
6. Returns 400 for invalid source, 404 if upstream fails

Universal URL pattern (from xword-dl): `https://syndication.andrewsmcmeel.com/uupuz/[YYMMDD]/uclick/fc/fcx[YYMMDD].puz`
- Format date as YYMMDD (e.g., 260111 for Jan 11, 2026)

Add error handling for upstream timeouts (10s limit).
  </action>
  <verify>
```bash
cd proxy && npx tsc --noEmit
```
TypeScript compiles without errors.
  </verify>
  <done>Worker code exists in proxy/src/index.ts, handles /puzzle endpoint with CORS</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Authenticate Cloudflare CLI (wrangler) for deployment</action>
  <instructions>
I've created the Worker code but need Cloudflare authentication to deploy.

1. If you don't have a Cloudflare account, create one at https://dash.cloudflare.com/sign-up (free)
2. Run in the proxy/ directory:
   ```bash
   cd proxy && npx wrangler login
   ```
3. This opens a browser for OAuth - authorize the CLI

The free tier includes 100,000 requests/day which is more than enough for puzzle downloads.
  </instructions>
  <verification>Run `npx wrangler whoami` to confirm authentication</verification>
  <resume-signal>Type "done" when authenticated, or "skip" if you want to defer deployment</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Deploy Worker and verify</name>
  <files>proxy/</files>
  <action>
Deploy the Worker to Cloudflare:
```bash
cd proxy && npx wrangler deploy
```

Capture the deployment URL (should be `crossing-words-proxy.<account>.workers.dev`).

Test the deployed Worker with curl:
```bash
curl -X POST https://crossing-words-proxy.<account>.workers.dev/puzzle \
  -H "Content-Type: application/json" \
  -d '{"source":"universal","date":"2026-01-10T00:00:00.000Z"}'
```

Should return binary .puz data (will show garbled text in terminal - that's expected).

Also test CORS preflight:
```bash
curl -X OPTIONS https://crossing-words-proxy.<account>.workers.dev/puzzle \
  -H "Origin: http://localhost:5173" -v
```
Should return 200 with Access-Control-Allow-* headers.

If deployment skipped (user typed "skip"), document the proxy URL as "NOT_DEPLOYED" and note that local development will need a mock or manual proxy.
  </action>
  <verify>curl POST to /puzzle returns data (or documents skip status)</verify>
  <done>Worker deployed and responding to /puzzle requests with CORS headers, OR deployment deferred with documentation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] proxy/ directory exists with Worker code
- [ ] TypeScript compiles without errors
- [ ] Worker deployed OR deployment deferred (documented)
- [ ] If deployed: /puzzle endpoint returns puzzle data with CORS headers
</verification>

<success_criteria>
- Worker code created with CORS handling
- Universal source URL pattern implemented
- Deployment attempted (or explicitly deferred)
- Proxy URL documented for next plan
</success_criteria>

<output>
After completion, create `.planning/phases/3.1-automatic-downloader-from-remote-sources-with-picker-for-source-and-day/3.1-01-SUMMARY.md`:

# Phase 3.1 Plan 01: Cloudflare Worker Proxy Summary

**[One-liner: what was accomplished]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `proxy/src/index.ts` - Worker entry point
- `proxy/wrangler.toml` - Worker configuration
- `proxy/package.json` - Dependencies
- `proxy/tsconfig.json` - TypeScript config

## Decisions Made

- Proxy URL: [deployed URL or "NOT_DEPLOYED"]
- [Any other decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 3.1-02-PLAN.md (Source service and Downloader UI)
</output>
