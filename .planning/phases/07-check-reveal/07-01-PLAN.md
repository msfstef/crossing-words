---
phase: 07-check-reveal
plan: 01
type: execute
---

<objective>
Add CRDT verification state maps and utility functions for check/reveal operations.

Purpose: Establish the data layer for verification - synced state for verified cells and error markers, plus pure functions for checking entries against solutions.
Output: Extended puzzleDoc with verified/errors maps, verification utilities, and useVerification hook.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-check-reveal/07-CONTEXT.md
@.planning/phases/07-check-reveal/07-RESEARCH.md

# Key files from prior phases:
@src/crdt/puzzleDoc.ts
@src/hooks/useCrdtPuzzle.ts
@src/types/puzzle.ts

**Tech stack available:** yjs, y-indexeddb, react, useSyncExternalStore pattern
**Established patterns:**
- Y.Map for synced state with "row,col" keys
- useSyncExternalStore for React integration
- Observer cleanup tracking pattern

**Constraining decisions:**
- Phase 04-02: useSyncExternalStore over useState for Yjs sync
- Phase 04-01: Flat Y.Map with 'row,col' keys for entries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend puzzleDoc with verified and errors maps</name>
  <files>src/crdt/puzzleDoc.ts</files>
  <action>
Add two new Y.Map accessors following the existing getEntriesMap pattern:

1. `VerifiedType = 'checked' | 'revealed'` - type for verification status
2. `VerifiedMap = Y.Map<VerifiedType>` - type alias
3. `ErrorsMap = Y.Map<boolean>` - type alias
4. `getVerifiedMap(doc: Y.Doc): VerifiedMap` - returns doc.getMap('verified')
5. `getErrorsMap(doc: Y.Doc): ErrorsMap` - returns doc.getMap('errors')

Both maps use the same "row,col" key format as entries for consistency. This ensures all cell state is keyed identically across maps.

The maps are separate (not nested) to follow the flat Y.Map pattern established in Phase 4 - this keeps CRDT operations simple and conflict resolution predictable.
  </action>
  <verify>TypeScript compiles without errors: `npm run build`</verify>
  <done>puzzleDoc.ts exports VerifiedType, VerifiedMap, ErrorsMap types and getVerifiedMap(), getErrorsMap() functions</done>
</task>

<task type="auto">
  <name>Task 2: Create verification utility functions</name>
  <files>src/utils/verification.ts</files>
  <action>
Create a new utils/verification.ts file with pure functions for checking entries against solutions:

```typescript
import type { Puzzle } from '../types/puzzle';

export type CheckResult = 'correct' | 'incorrect' | 'empty';

export function checkCell(
  puzzle: Puzzle,
  row: number,
  col: number,
  userEntry: string | undefined
): CheckResult {
  const cell = puzzle.grid[row][col];
  if (cell.isBlack) return 'empty';

  const solution = cell.letter;
  if (!userEntry) return 'empty';
  return userEntry === solution ? 'correct' : 'incorrect';
}

export function checkWord(
  puzzle: Puzzle,
  cells: { row: number; col: number }[],
  entries: Map<string, string>
): { correct: string[]; incorrect: string[]; empty: string[] } {
  const result = { correct: [] as string[], incorrect: [] as string[], empty: [] as string[] };
  for (const { row, col } of cells) {
    const key = `${row},${col}`;
    const status = checkCell(puzzle, row, col, entries.get(key));
    result[status].push(key);
  }
  return result;
}

export function checkPuzzle(
  puzzle: Puzzle,
  entries: Map<string, string>
): { correct: string[]; incorrect: string[]; empty: string[] } {
  const result = { correct: [] as string[], incorrect: [] as string[], empty: [] as string[] };
  for (let row = 0; row < puzzle.height; row++) {
    for (let col = 0; col < puzzle.width; col++) {
      if (puzzle.grid[row][col].isBlack) continue;
      const key = `${row},${col}`;
      const status = checkCell(puzzle, row, col, entries.get(key));
      result[status].push(key);
    }
  }
  return result;
}
```

These are pure functions with no side effects - they just compare entries to solutions. The actual CRDT updates happen in the hook.
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>src/utils/verification.ts exports checkCell, checkWord, checkPuzzle functions</done>
</task>

<task type="auto">
  <name>Task 3: Create useVerification hook</name>
  <files>src/hooks/useVerification.ts</files>
  <action>
Create useVerification hook that uses the verification utils and updates CRDT state:

```typescript
import { useCallback } from 'react';
import type * as Y from 'yjs';
import type { Puzzle } from '../types/puzzle';
import type { VerifiedType } from '../crdt/puzzleDoc';
import { checkCell, checkWord as checkWordUtil, checkPuzzle as checkPuzzleUtil } from '../utils/verification';

interface UseVerificationOptions {
  puzzle: Puzzle;
  entries: Map<string, string>;
  entriesMap: Y.Map<string>;
  verifiedMap: Y.Map<VerifiedType>;
  errorsMap: Y.Map<boolean>;
  doc: Y.Doc;
  currentWord: { row: number; col: number }[] | null;
  selectedCell: { row: number; col: number } | null;
}

export function useVerification({
  puzzle,
  entries,
  entriesMap,
  verifiedMap,
  errorsMap,
  doc,
  currentWord,
  selectedCell,
}: UseVerificationOptions) {

  // Check operations - mark correct as verified, incorrect as error
  const checkLetter = useCallback(() => {
    if (!selectedCell) return;
    const { row, col } = selectedCell;
    const key = `${row},${col}`;

    // Skip if already verified
    if (verifiedMap.has(key)) return;

    const result = checkCell(puzzle, row, col, entries.get(key));

    doc.transact(() => {
      if (result === 'correct') {
        verifiedMap.set(key, 'checked');
        errorsMap.delete(key);
      } else if (result === 'incorrect') {
        errorsMap.set(key, true);
      }
    });
  }, [puzzle, entries, verifiedMap, errorsMap, doc, selectedCell]);

  const checkWord = useCallback(() => {
    if (!currentWord) return;

    const result = checkWordUtil(puzzle, currentWord, entries);

    doc.transact(() => {
      for (const key of result.correct) {
        if (!verifiedMap.has(key)) {
          verifiedMap.set(key, 'checked');
          errorsMap.delete(key);
        }
      }
      for (const key of result.incorrect) {
        if (!verifiedMap.has(key)) {
          errorsMap.set(key, true);
        }
      }
    });
  }, [puzzle, entries, currentWord, verifiedMap, errorsMap, doc]);

  const checkPuzzle = useCallback(() => {
    const result = checkPuzzleUtil(puzzle, entries);

    doc.transact(() => {
      for (const key of result.correct) {
        if (!verifiedMap.has(key)) {
          verifiedMap.set(key, 'checked');
          errorsMap.delete(key);
        }
      }
      for (const key of result.incorrect) {
        if (!verifiedMap.has(key)) {
          errorsMap.set(key, true);
        }
      }
    });
  }, [puzzle, entries, verifiedMap, errorsMap, doc]);

  // Reveal operations - set entry to solution and mark as revealed
  const revealLetter = useCallback(() => {
    if (!selectedCell) return;
    const { row, col } = selectedCell;
    const key = `${row},${col}`;

    // Skip if already verified
    if (verifiedMap.has(key)) return;

    const cell = puzzle.grid[row][col];
    if (!cell.letter) return;

    doc.transact(() => {
      entriesMap.set(key, cell.letter!);
      verifiedMap.set(key, 'revealed');
      errorsMap.delete(key);
    });
  }, [puzzle, entriesMap, verifiedMap, errorsMap, doc, selectedCell]);

  const revealWord = useCallback(() => {
    if (!currentWord) return;

    doc.transact(() => {
      for (const { row, col } of currentWord) {
        const key = `${row},${col}`;
        if (verifiedMap.has(key)) continue;

        const cell = puzzle.grid[row][col];
        if (!cell.letter) continue;

        entriesMap.set(key, cell.letter);
        verifiedMap.set(key, 'revealed');
        errorsMap.delete(key);
      }
    });
  }, [puzzle, currentWord, entriesMap, verifiedMap, errorsMap, doc]);

  const revealPuzzle = useCallback(() => {
    doc.transact(() => {
      for (let row = 0; row < puzzle.height; row++) {
        for (let col = 0; col < puzzle.width; col++) {
          const cell = puzzle.grid[row][col];
          if (cell.isBlack || !cell.letter) continue;

          const key = `${row},${col}`;
          if (verifiedMap.has(key)) continue;

          entriesMap.set(key, cell.letter);
          verifiedMap.set(key, 'revealed');
          errorsMap.delete(key);
        }
      }
    });
  }, [puzzle, entriesMap, verifiedMap, errorsMap, doc]);

  return {
    checkLetter,
    checkWord,
    checkPuzzle,
    revealLetter,
    revealWord,
    revealPuzzle,
  };
}
```

Key decisions:
- Use doc.transact() for atomic batch updates (prevents race conditions on concurrent check)
- Skip already-verified cells (verified is terminal state)
- Clear errors when marking verified (clean state transition)
- Return 6 action callbacks for UI to wire up
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>src/hooks/useVerification.ts exports useVerification hook with checkLetter, checkWord, checkPuzzle, revealLetter, revealWord, revealPuzzle</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] puzzleDoc.ts has new types and accessor functions
- [ ] verification.ts has pure check functions
- [ ] useVerification.ts has hook with all 6 actions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- CRDT state extension ready for UI integration
</success_criteria>

<output>
After completion, create `.planning/phases/07-check-reveal/07-01-SUMMARY.md`
</output>
