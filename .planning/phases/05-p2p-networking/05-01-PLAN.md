---
phase: 05-p2p-networking
plan: 01
type: execute
---

<objective>
Integrate y-webrtc provider for peer-to-peer CRDT synchronization.

Purpose: Enable real-time puzzle collaboration by connecting Y.Doc instances across peers via WebRTC.
Output: Working P2P sync where two browser windows sharing a roomId see each other's keystrokes instantly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-p2p-networking/05-RESEARCH.md
@.planning/phases/05-p2p-networking/05-CONTEXT.md
@.planning/phases/04-crdt-state/04-02-SUMMARY.md

@src/crdt/puzzleStore.ts
@src/crdt/puzzleDoc.ts
@src/hooks/useCrdtPuzzle.ts

**Tech stack available:**
- yjs, y-indexeddb (from Phase 4)
- React 19, Vite, TypeScript

**Established patterns:**
- PuzzleStore.doc ready for provider attachment
- useSyncExternalStore for external state sync
- Observer cleanup tracking pattern

**Constraining decisions:**
- Phase 4: One Y.Doc per puzzle, PuzzleStore.ready promise pattern
- Phase 4: puzzleId derived from sanitized title

**From RESEARCH.md - Don't hand-roll:**
- WebRTC peer discovery → use y-webrtc signaling
- Peer connection management → use y-webrtc/simple-peer
- NAT traversal → configure ICE servers, don't implement
- Document sync over WebRTC → y-webrtc handles automatically
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install y-webrtc and create webrtcProvider module</name>
  <files>package.json, src/crdt/webrtcProvider.ts</files>
  <action>
1. Install y-webrtc: `npm install y-webrtc`

2. Create src/crdt/webrtcProvider.ts with:
   - ICE_SERVERS constant with STUN servers (Google, Twilio) + TURN fallback (Open Relay)
   - SIGNALING_SERVERS constant using y-webrtc defaults for now (wss://signaling.yjs.dev, etc.)
   - P2PSession interface with provider and destroy method
   - createP2PSession(store: PuzzleStore, roomId: string): Promise<P2PSession>
     - Await store.ready before creating provider (critical - prevents empty state sync)
     - Create WebrtcProvider with roomId, store.doc, signaling URLs, and peerOpts.config.iceServers
     - Return session object with provider reference and destroy cleanup function

3. ICE server configuration (from RESEARCH.md):
```typescript
const ICE_SERVERS: RTCIceServer[] = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:global.stun.twilio.com:3478' },
  {
    urls: [
      'turn:staticauth.openrelay.metered.ca:80',
      'turn:staticauth.openrelay.metered.ca:443',
      'turns:staticauth.openrelay.metered.ca:443'
    ],
    username: 'openrelayproject',
    credential: 'openrelayproject'
  }
];
```

4. Export types and createP2PSession function
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>webrtcProvider.ts exists with createP2PSession function, ICE servers configured with TURN fallback</done>
</task>

<task type="auto">
  <name>Task 2: Add P2P session support to useCrdtPuzzle hook</name>
  <files>src/hooks/useCrdtPuzzle.ts</files>
  <action>
1. Add optional roomId parameter to useCrdtPuzzle(puzzleId: string, roomId?: string)

2. Add P2P session management:
   - Import createP2PSession and P2PSession from webrtcProvider
   - Add sessionRef = useRef<P2PSession | null>(null)
   - In the existing useEffect (after store.ready resolves):
     - If roomId is provided, call createP2PSession(store, roomId)
     - Store result in sessionRef.current
   - In cleanup: call sessionRef.current?.destroy() before store.destroy()

3. Key ordering (critical for correct behavior):
   - Create store
   - Wait for store.ready (IndexedDB sync)
   - THEN create P2P session (so local state is loaded first)
   - On cleanup: destroy session THEN destroy store

4. Update UseCrdtPuzzleReturn interface to include:
   - roomId: string | undefined (echo back for consumers)

5. DO NOT add connection state tracking yet - that's Plan 2
  </action>
  <verify>npm run build succeeds, no TypeScript errors</verify>
  <done>useCrdtPuzzle accepts optional roomId, creates P2P session after IndexedDB ready, cleans up properly</done>
</task>

<task type="auto">
  <name>Task 3: Verify P2P sync with Playwright multi-context test</name>
  <files>package.json, playwright.config.ts, e2e/p2p-sync.spec.ts</files>
  <action>
1. Install Playwright if not present: `npm install -D @playwright/test && npx playwright install chromium`

2. Create playwright.config.ts with basic config:
   - webServer pointing to `npm run dev` on localhost:5173
   - Use chromium only for now
   - testDir: './e2e'

3. Create e2e/p2p-sync.spec.ts:
   - Import test, expect from @playwright/test
   - Test: "two peers sync keystrokes"
     a. Create two browser contexts (browser.newContext() x2)
     b. Create pages from each context
     c. Generate unique roomId (e.g., `test-room-${Date.now()}`)
     d. Both pages navigate to app with roomId in URL hash: `/#room=${roomId}`
     e. Wait for puzzle grid to be ready in both
     f. In page1: click a cell, type a letter (e.g., 'A')
     g. Wait briefly for sync (500ms should be plenty)
     h. In page2: verify the same cell shows 'A'
     i. Reverse: page2 types 'B' in different cell, verify page1 sees it

4. Update App.tsx to read roomId from URL hash:
   - Parse window.location.hash for room parameter
   - Pass roomId to useCrdtPuzzle if present
   - Add effect to update hash when roomId changes (for manual testing)

5. Run test: `npx playwright test e2e/p2p-sync.spec.ts`
  </action>
  <verify>npx playwright test e2e/p2p-sync.spec.ts passes</verify>
  <done>Playwright test confirms two browser contexts sync keystrokes via WebRTC</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes (or only pre-existing warnings)
- [ ] `npx playwright test e2e/p2p-sync.spec.ts` passes
- [ ] Manual test: open two browser windows with same #room=X, typing syncs
</verification>

<success_criteria>

- y-webrtc installed and configured with STUN + TURN servers
- createP2PSession function creates WebrtcProvider attached to PuzzleStore.doc
- useCrdtPuzzle accepts optional roomId for P2P mode
- P2P session lifecycle managed correctly (create after IndexedDB ready, destroy on cleanup)
- Playwright test validates two-peer sync works
- App reads roomId from URL hash for easy testing
</success_criteria>

<output>
After completion, create `.planning/phases/05-p2p-networking/05-01-SUMMARY.md`
</output>
